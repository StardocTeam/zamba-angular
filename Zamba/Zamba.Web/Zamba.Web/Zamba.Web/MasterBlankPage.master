<%@ Master Language="C#" Inherits="Zamba.Web.MasterBlankPage" AutoEventWireup="true" CodeBehind="MasterBlankPage.master.cs" %>

<%@ Import Namespace="System.Web.Optimization" %>
<!DOCTYPE html>
<html>
<head id="Head2" runat="server">

    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11; IE=9; IE=8; IE=7; IE=EDGE,chrome=1" />
    <title title="Zamba Web"></title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta property="AntiForgeryToken" value="#AntiForgeryToken"/>
    
    <asp:ContentPlaceHolder ID="header_css" runat="server">
    </asp:ContentPlaceHolder>
    <link rel="shortcut icon" id="lnkWebIcon" runat="server" type="image/x-icon" />

    <asp:PlaceHolder runat="server">
        <%:Scripts.Render("~/bundles/jqueryCore") %>
        <%:Styles.Render("~/Content/themes/base/datepicker")%>

        <%:Styles.Render("~/bundles/Styles/ZStyles")%>
    
        <%:Styles.Render("~/bundles/Styles/bootstrap")%>

        <%:Styles.Render("~/bundles/Styles/grids")%>
        <%:Scripts.Render( "~/bundles/modernizr") %>
        <%:Scripts.Render("~/bundles/jqueryAddIns") %>
        <%:Scripts.Render("~/bundles/tabber") %>

<%--        <script src="../../Scripts/jquery.validate.js?v=168"></script>
        <script src="../../Scripts/jquery.validate-vsdoc.js?v=168"></script>--%>
      

        <%:Scripts.Render("~/bundles/bootstrap") %>
        <%:Scripts.Render("~/bundles/moment") %>
        <%:Scripts.Render("~/bundles/angular") %>

    

        <script type="text/javascript">
            function getValueFromWebConfig(key) {
                var pathName = null;
                $.ajax({
                    "async": false,
                    "crossDomain": true,
                    "url": "../../Services/ViewsService.asmx/getValueFromWebConfig?key=" + key,
                    "method": "GET",
                    "headers": {
                        "cache-control": "no-cache"
                    },
                    "success": function (response) {
                        if (response.childNodes[0].innerHTML == undefined) {
                            pathName = response.childNodes[0].textContent;
                        } else {
                            pathName = response.childNodes[0].innerHTML;
                        }

                    },
                    "error": function (data, status, headers, config) {
                        console.log(data);
                    }
                });
                return pathName;
            }
            var photoValue = getValueFromWebConfig("WebClient");

            if (photoValue == "Marsh") {

                $("#ctl00_lnkWebIcon")[0].href = "../../App_Themes/Marsh/Images/WebIcon.jpg";
            }

            var thisDomain = location.origin.trim() + getValueFromWebConfig("ThisDomain");
            var ZambaWebRestApiURL = location.origin.trim() + getValueFromWebConfig("RestApiUrl") + "/api";
            var zambaApplication = "Zamba";
            var URLServer = thisDomain + "/ZambaChat7/";
            var urlGlobalSearch = thisDomain + "/Views/Search/";
            var URLServer = thisDomain + "/ZambaChat7/";

 //        var URLServer ='<%=Zamba.Core.ZOptBusiness.GetValueOrDefault("ChatURLServer","http://www.zamba.com.ar/zambastardoc/ZambaChat7/") %>';

// var thisDomain = location.origin.trim() + getValueFromWebConfig("ThisDomain"),
  //          ZambaWebRestApiURL = location.origin.trim() + getValueFromWebConfig("RestApiUrl") + "/api",
    //        zambaApplication = "Zamba";

//var thisDomain ='<%=Zamba.Membership.MembershipHelper.AppUrl %>';  

            $(document).ready(function () {
                document.config = {
                    urlBase: "<%=GetAppRootUrl(false) %>",

                };
            });

        </script>
        
        <script>
            /**
     * Copyright (c) 2014, Facebook, Inc.
     * All rights reserved.
     *
     * This source code is licensed under the BSD-style license found in the
     * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
     * additional grant of patent rights can be found in the PATENTS file in
     * the same directory.
     */

            !(function (global) {
                "use strict";

                var hasOwn = Object.prototype.hasOwnProperty;
                var undefined; // More compressible than void 0.
                var iteratorSymbol =
                    typeof Symbol === "function" && Symbol.iterator || "@@iterator";

                var inModule = typeof module === "object";
                var runtime = global.regeneratorRuntime;
                if (runtime) {
                    if (inModule) {
                        // If regeneratorRuntime is defined globally and we're in a module,
                        // make the exports object identical to regeneratorRuntime.
                        module.exports = runtime;
                    }
                    // Don't bother evaluating the rest of this file if the runtime was
                    // already defined globally.
                    return;
                }

                // Define the runtime globally (as expected by generated code) as either
                // module.exports (if we're in a module) or a new, empty object.
                runtime = global.regeneratorRuntime = inModule ? module.exports : {};

                function wrap(innerFn, outerFn, self, tryLocsList) {
                    // If outerFn provided, then outerFn.prototype instanceof Generator.
                    var generator = Object.create((outerFn || Generator).prototype);
                    var context = new Context(tryLocsList || []);

                    // The ._invoke method unifies the implementations of the .next,
                    // .throw, and .return methods.
                    generator._invoke = makeInvokeMethod(innerFn, self, context);

                    return generator;
                }
                runtime.wrap = wrap;

                // Try/catch helper to minimize deoptimizations. Returns a completion
                // record like context.tryEntries[i].completion. This interface could
                // have been (and was previously) designed to take a closure to be
                // invoked without arguments, but in all the cases we care about we
                // already have an existing method we want to call, so there's no need
                // to create a new function object. We can even get away with assuming
                // the method takes exactly one argument, since that happens to be true
                // in every case, so we don't have to touch the arguments object. The
                // only additional allocation required is the completion record, which
                // has a stable shape and so hopefully should be cheap to allocate.
                function tryCatch(fn, obj, arg) {
                    try {
                        return { type: "normal", arg: fn.call(obj, arg) };
                    } catch (err) {
                        return { type: "throw", arg: err };
                    }
                }

                var GenStateSuspendedStart = "suspendedStart";
                var GenStateSuspendedYield = "suspendedYield";
                var GenStateExecuting = "executing";
                var GenStateCompleted = "completed";

                // Returning this object from the innerFn has the same effect as
                // breaking out of the dispatch switch statement.
                var ContinueSentinel = {};

                // Dummy constructor functions that we use as the .constructor and
                // .constructor.prototype properties for functions that return Generator
                // objects. For full spec compliance, you may wish to configure your
                // minifier not to mangle the names of these two functions.
                function Generator() { }
                function GeneratorFunction() { }
                function GeneratorFunctionPrototype() { }

                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
                GeneratorFunctionPrototype.constructor = GeneratorFunction;
                GeneratorFunction.displayName = "GeneratorFunction";

                // Helper for defining the .next, .throw, and .return methods of the
                // Iterator interface in terms of a single ._invoke method.
                function defineIteratorMethods(prototype) {
                    ["next", "throw", "return"].forEach(function (method) {
                        prototype[method] = function (arg) {
                            return this._invoke(method, arg);
                        };
                    });
                }

                runtime.isGeneratorFunction = function (genFun) {
                    var ctor = typeof genFun === "function" && genFun.constructor;
                    return ctor
                        ? ctor === GeneratorFunction ||
                        // For the native GeneratorFunction constructor, the best we can
                        // do is to check its .name property.
                        (ctor.displayName || ctor.name) === "GeneratorFunction"
                        : false;
                };

                runtime.mark = function (genFun) {
                    if (Object.setPrototypeOf) {
                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
                    } else {
                        genFun.__proto__ = GeneratorFunctionPrototype;
                    }
                    genFun.prototype = Object.create(Gp);
                    return genFun;
                };

                // Within the body of any async function, `await x` is transformed to
                // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
                // `value instanceof AwaitArgument` to determine if the yielded value is
                // meant to be awaited. Some may consider the name of this method too
                // cutesy, but they are curmudgeons.
                runtime.awrap = function (arg) {
                    return new AwaitArgument(arg);
                };

                function AwaitArgument(arg) {
                    this.arg = arg;
                }

                function AsyncIterator(generator) {
                    // This invoke function is written in a style that assumes some
                    // calling function (or Promise) will handle exceptions.
                    function invoke(method, arg) {
                        var result = generator[method](arg);
                        var value = result.value;
                        return value instanceof AwaitArgument
                            ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)
                            : Promise.resolve(value).then(function (unwrapped) {
                                // When a yielded Promise is resolved, its final value becomes
                                // the .value of the Promise<{value,done}> result for the
                                // current iteration. If the Promise is rejected, however, the
                                // result for this iteration will be rejected with the same
                                // reason. Note that rejections of yielded Promises are not
                                // thrown back into the generator function, as is the case
                                // when an awaited Promise is rejected. This difference in
                                // behavior between yield and await is important, because it
                                // allows the consumer to decide what to do with the yielded
                                // rejection (swallow it and continue, manually .throw it back
                                // into the generator, abandon iteration, whatever). With
                                // await, by contrast, there is no opportunity to examine the
                                // rejection reason outside the generator function, so the
                                // only option is to throw it from the await expression, and
                                // let the generator function handle the exception.
                                result.value = unwrapped;
                                return result;
                            });
                    }

                    if (typeof process === "object" && process.domain) {
                        invoke = process.domain.bind(invoke);
                    }

                    var invokeNext = invoke.bind(generator, "next");
                    var invokeThrow = invoke.bind(generator, "throw");
                    var invokeReturn = invoke.bind(generator, "return");
                    var previousPromise;

                    function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                            return invoke(method, arg);
                        }

                        return previousPromise =
                            // If enqueue has been called before, then we want to wait until
                            // all previous Promises have been resolved before calling invoke,
                            // so that results are always delivered in the correct order. If
                            // enqueue has not been called before, then it is important to
                            // call invoke immediately, without waiting on a callback to fire,
                            // so that the async generator function has the opportunity to do
                            // any necessary setup in a predictable way. This predictability
                            // is why the Promise constructor synchronously invokes its
                            // executor callback, and why async functions synchronously
                            // execute code before the first await. Since we implement simple
                            // async functions in terms of async generators, it is especially
                            // important to get this right, even though it requires care.
                            previousPromise ? previousPromise.then(
                                callInvokeWithMethodAndArg,
                                // Avoid propagating failures to Promises returned by later
                                // invocations of the iterator.
                                callInvokeWithMethodAndArg
                            ) : new Promise(function (resolve) {
                                resolve(callInvokeWithMethodAndArg());
                            });
                    }

                    // Define the unified helper method that is used to implement .next,
                    // .throw, and .return (see defineIteratorMethods).
                    this._invoke = enqueue;
                }

                defineIteratorMethods(AsyncIterator.prototype);

                // Note that simple async functions are implemented on top of
                // AsyncIterator objects; they just return a Promise for the value of
                // the final result produced by the iterator.
                runtime.async = function (innerFn, outerFn, self, tryLocsList) {
                    var iter = new AsyncIterator(
                        wrap(innerFn, outerFn, self, tryLocsList)
                    );

                    return runtime.isGeneratorFunction(outerFn)
                        ? iter // If outerFn is a generator, return the full iterator.
                        : iter.next().then(function (result) {
                            return result.done ? result.value : iter.next();
                        });
                };

                function makeInvokeMethod(innerFn, self, context) {
                    var state = GenStateSuspendedStart;

                    return function invoke(method, arg) {
                        if (state === GenStateExecuting) {
                            throw new Error("Generator is already running");
                        }

                        if (state === GenStateCompleted) {
                            if (method === "throw") {
                                throw arg;
                            }

                            // Be forgiving, per 25.3.3.3.3 of the spec:
                            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                            return doneResult();
                        }

                        while (true) {
                            var delegate = context.delegate;
                            if (delegate) {
                                if (method === "return" ||
                                    (method === "throw" && delegate.iterator[method] === undefined)) {
                                    // A return or throw (when the delegate iterator has no throw
                                    // method) always terminates the yield* loop.
                                    context.delegate = null;

                                    // If the delegate iterator has a return method, give it a
                                    // chance to clean up.
                                    var returnMethod = delegate.iterator["return"];
                                    if (returnMethod) {
                                        var record = tryCatch(returnMethod, delegate.iterator, arg);
                                        if (record.type === "throw") {
                                            // If the return method threw an exception, let that
                                            // exception prevail over the original return or throw.
                                            method = "throw";
                                            arg = record.arg;
                                            continue;
                                        }
                                    }

                                    if (method === "return") {
                                        // Continue with the outer return, now that the delegate
                                        // iterator has been terminated.
                                        continue;
                                    }
                                }

                                var record = tryCatch(
                                    delegate.iterator[method],
                                    delegate.iterator,
                                    arg
                                );

                                if (record.type === "throw") {
                                    context.delegate = null;

                                    // Like returning generator.throw(uncaught), but without the
                                    // overhead of an extra function call.
                                    method = "throw";
                                    arg = record.arg;
                                    continue;
                                }

                                // Delegate generator ran and handled its own exceptions so
                                // regardless of what the method was, we continue as if it is
                                // "next" with an undefined arg.
                                method = "next";
                                arg = undefined;

                                var info = record.arg;
                                if (info.done) {
                                    context[delegate.resultName] = info.value;
                                    context.next = delegate.nextLoc;
                                } else {
                                    state = GenStateSuspendedYield;
                                    return info;
                                }

                                context.delegate = null;
                            }

                            if (method === "next") {
                                context._sent = arg;

                                if (state === GenStateSuspendedYield) {
                                    context.sent = arg;
                                } else {
                                    context.sent = undefined;
                                }
                            } else if (method === "throw") {
                                if (state === GenStateSuspendedStart) {
                                    state = GenStateCompleted;
                                    throw arg;
                                }

                                if (context.dispatchException(arg)) {
                                    // If the dispatched exception was caught by a catch block,
                                    // then let that catch block handle the exception normally.
                                    method = "next";
                                    arg = undefined;
                                }

                            } else if (method === "return") {
                                context.abrupt("return", arg);
                            }

                            state = GenStateExecuting;

                            var record = tryCatch(innerFn, self, context);
                            if (record.type === "normal") {
                                // If an exception is thrown from innerFn, we leave state ===
                                // GenStateExecuting and loop back for another invocation.
                                state = context.done
                                    ? GenStateCompleted
                                    : GenStateSuspendedYield;

                                var info = {
                                    value: record.arg,
                                    done: context.done
                                };

                                if (record.arg === ContinueSentinel) {
                                    if (context.delegate && method === "next") {
                                        // Deliberately forget the last sent value so that we don't
                                        // accidentally pass it on to the delegate.
                                        arg = undefined;
                                    }
                                } else {
                                    return info;
                                }

                            } else if (record.type === "throw") {
                                state = GenStateCompleted;
                                // Dispatch the exception by looping back around to the
                                // context.dispatchException(arg) call above.
                                method = "throw";
                                arg = record.arg;
                            }
                        }
                    };
                }

                // Define Generator.prototype.{next,throw,return} in terms of the
                // unified ._invoke helper method.
                defineIteratorMethods(Gp);

                Gp[iteratorSymbol] = function () {
                    return this;
                };

                Gp.toString = function () {
                    return "[object Generator]";
                };

                function pushTryEntry(locs) {
                    var entry = { tryLoc: locs[0] };

                    if (1 in locs) {
                        entry.catchLoc = locs[1];
                    }

                    if (2 in locs) {
                        entry.finallyLoc = locs[2];
                        entry.afterLoc = locs[3];
                    }

                    this.tryEntries.push(entry);
                }

                function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal";
                    delete record.arg;
                    entry.completion = record;
                }

                function Context(tryLocsList) {
                    // The root entry object (effectively a try statement without a catch
                    // or a finally block) gives us a place to store values thrown from
                    // locations where there is no enclosing try statement.
                    this.tryEntries = [{ tryLoc: "root" }];
                    tryLocsList.forEach(pushTryEntry, this);
                    this.reset(true);
                }

                runtime.keys = function (object) {
                    var keys = [];
                    for (var key in object) {
                        keys.push(key);
                    }
                    keys.reverse();

                    // Rather than returning an object with a next method, we keep
                    // things simple and return the next function itself.
                    return function next() {
                        while (keys.length) {
                            var key = keys.pop();
                            if (key in object) {
                                next.value = key;
                                next.done = false;
                                return next;
                            }
                        }

                        // To avoid creating an additional object, we just hang the .value
                        // and .done properties off the next function object itself. This
                        // also ensures that the minifier will not anonymize the function.
                        next.done = true;
                        return next;
                    };
                };

                function values(iterable) {
                    if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) {
                            return iteratorMethod.call(iterable);
                        }

                        if (typeof iterable.next === "function") {
                            return iterable;
                        }

                        if (!isNaN(iterable.length)) {
                            var i = -1, next = function next() {
                                while (++i < iterable.length) {
                                    if (hasOwn.call(iterable, i)) {
                                        next.value = iterable[i];
                                        next.done = false;
                                        return next;
                                    }
                                }

                                next.value = undefined;
                                next.done = true;

                                return next;
                            };

                            return next.next = next;
                        }
                    }

                    // Return an iterator with no values.
                    return { next: doneResult };
                }
                runtime.values = values;

                function doneResult() {
                    return { value: undefined, done: true };
                }

                Context.prototype = {
                    constructor: Context,

                    reset: function (skipTempReset) {
                        this.prev = 0;
                        this.next = 0;
                        this.sent = undefined;
                        this.done = false;
                        this.delegate = null;

                        this.tryEntries.forEach(resetTryEntry);

                        if (!skipTempReset) {
                            for (var name in this) {
                                // Not sure about the optimal order of these conditions:
                                if (name.charAt(0) === "t" &&
                                    hasOwn.call(this, name) &&
                                    !isNaN(+name.slice(1))) {
                                    this[name] = undefined;
                                }
                            }
                        }
                    },

                    stop: function () {
                        this.done = true;

                        var rootEntry = this.tryEntries[0];
                        var rootRecord = rootEntry.completion;
                        if (rootRecord.type === "throw") {
                            throw rootRecord.arg;
                        }

                        return this.rval;
                    },

                    dispatchException: function (exception) {
                        if (this.done) {
                            throw exception;
                        }

                        var context = this;
                        function handle(loc, caught) {
                            record.type = "throw";
                            record.arg = exception;
                            context.next = loc;
                            return !!caught;
                        }

                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            var record = entry.completion;

                            if (entry.tryLoc === "root") {
                                // Exception thrown outside of any try block that could handle
                                // it, so set the completion value of the entire function to
                                // throw the exception.
                                return handle("end");
                            }

                            if (entry.tryLoc <= this.prev) {
                                var hasCatch = hasOwn.call(entry, "catchLoc");
                                var hasFinally = hasOwn.call(entry, "finallyLoc");

                                if (hasCatch && hasFinally) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    } else if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }

                                } else if (hasCatch) {
                                    if (this.prev < entry.catchLoc) {
                                        return handle(entry.catchLoc, true);
                                    }

                                } else if (hasFinally) {
                                    if (this.prev < entry.finallyLoc) {
                                        return handle(entry.finallyLoc);
                                    }

                                } else {
                                    throw new Error("try statement without catch or finally");
                                }
                            }
                        }
                    },

                    abrupt: function (type, arg) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc <= this.prev &&
                                hasOwn.call(entry, "finallyLoc") &&
                                this.prev < entry.finallyLoc) {
                                var finallyEntry = entry;
                                break;
                            }
                        }

                        if (finallyEntry &&
                            (type === "break" ||
                                type === "continue") &&
                            finallyEntry.tryLoc <= arg &&
                            arg <= finallyEntry.finallyLoc) {
                            // Ignore the finally entry if control is not jumping to a
                            // location outside the try/catch block.
                            finallyEntry = null;
                        }

                        var record = finallyEntry ? finallyEntry.completion : {};
                        record.type = type;
                        record.arg = arg;

                        if (finallyEntry) {
                            this.next = finallyEntry.finallyLoc;
                        } else {
                            this.complete(record);
                        }

                        return ContinueSentinel;
                    },

                    complete: function (record, afterLoc) {
                        if (record.type === "throw") {
                            throw record.arg;
                        }

                        if (record.type === "break" ||
                            record.type === "continue") {
                            this.next = record.arg;
                        } else if (record.type === "return") {
                            this.rval = record.arg;
                            this.next = "end";
                        } else if (record.type === "normal" && afterLoc) {
                            this.next = afterLoc;
                        }
                    },

                    finish: function (finallyLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.finallyLoc === finallyLoc) {
                                this.complete(entry.completion, entry.afterLoc);
                                resetTryEntry(entry);
                                return ContinueSentinel;
                            }
                        }
                    },

                    "catch": function (tryLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc === tryLoc) {
                                var record = entry.completion;
                                if (record.type === "throw") {
                                    var thrown = record.arg;
                                    resetTryEntry(entry);
                                }
                                return thrown;
                            }
                        }

                        // The context.catch method must only be called with a location
                        // argument that corresponds to a known catch block.
                        throw new Error("illegal catch attempt");
                    },

                    delegateYield: function (iterable, resultName, nextLoc) {
                        this.delegate = {
                            iterator: values(iterable),
                            resultName: resultName,
                            nextLoc: nextLoc
                        };

                        return ContinueSentinel;
                    }
                };
            })(
                // Among the various tricks for obtaining a reference to the global
                // object, this seems to be the most reliable technique that does not
                // use indirect eval (which violates Content Security Policy).
                typeof global === "object" ? global :
                    typeof window === "object" ? window :
                        typeof self === "object" ? self : this
            );

            !function (e, n) { "object" == typeof exports && "undefined" != typeof module ? n() : "function" == typeof define && define.amd ? define(n) : n() }(0, function () { "use strict"; function e(e) { var n = this.constructor; return this.then(function (t) { return n.resolve(e()).then(function () { return t }) }, function (t) { return n.resolve(e()).then(function () { return n.reject(t) }) }) } function n() { } function t(e) { if (!(this instanceof t)) throw new TypeError("Promises must be constructed via new"); if ("function" != typeof e) throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = undefined, this._deferreds = [], u(e, this) } function o(e, n) { for (; 3 === e._state;)e = e._value; 0 !== e._state ? (e._handled = !0, t._immediateFn(function () { var t = 1 === e._state ? n.onFulfilled : n.onRejected; if (null !== t) { var o; try { o = t(e._value) } catch (f) { return void i(n.promise, f) } r(n.promise, o) } else (1 === e._state ? r : i)(n.promise, e._value) })) : e._deferreds.push(n) } function r(e, n) { try { if (n === e) throw new TypeError("A promise cannot be resolved with itself."); if (n && ("object" == typeof n || "function" == typeof n)) { var o = n.then; if (n instanceof t) return e._state = 3, e._value = n, void f(e); if ("function" == typeof o) return void u(function (e, n) { return function () { e.apply(n, arguments) } }(o, n), e) } e._state = 1, e._value = n, f(e) } catch (r) { i(e, r) } } function i(e, n) { e._state = 2, e._value = n, f(e) } function f(e) { 2 === e._state && 0 === e._deferreds.length && t._immediateFn(function () { e._handled || t._unhandledRejectionFn(e._value) }); for (var n = 0, r = e._deferreds.length; r > n; n++)o(e, e._deferreds[n]); e._deferreds = null } function u(e, n) { var t = !1; try { e(function (e) { t || (t = !0, r(n, e)) }, function (e) { t || (t = !0, i(n, e)) }) } catch (o) { if (t) return; t = !0, i(n, o) } } var c = setTimeout; t.prototype["catch"] = function (e) { return this.then(null, e) }, t.prototype.then = function (e, t) { var r = new this.constructor(n); return o(this, new function (e, n, t) { this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof n ? n : null, this.promise = t }(e, t, r)), r }, t.prototype["finally"] = e, t.all = function (e) { return new t(function (n, t) { function o(e, f) { try { if (f && ("object" == typeof f || "function" == typeof f)) { var u = f.then; if ("function" == typeof u) return void u.call(f, function (n) { o(e, n) }, t) } r[e] = f, 0 == --i && n(r) } catch (c) { t(c) } } if (!e || "undefined" == typeof e.length) throw new TypeError("Promise.all accepts an array"); var r = Array.prototype.slice.call(e); if (0 === r.length) return n([]); for (var i = r.length, f = 0; r.length > f; f++)o(f, r[f]) }) }, t.resolve = function (e) { return e && "object" == typeof e && e.constructor === t ? e : new t(function (n) { n(e) }) }, t.reject = function (e) { return new t(function (n, t) { t(e) }) }, t.race = function (e) { return new t(function (n, t) { for (var o = 0, r = e.length; r > o; o++)e[o].then(n, t) }) }, t._immediateFn = "function" == typeof setImmediate && function (e) { setImmediate(e) } || function (e) { c(e, 0) }, t._unhandledRejectionFn = function (e) { void 0 !== console && console && console.warn("Possible Unhandled Promise Rejection:", e) }; var l = function () { if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if ("undefined" != typeof global) return global; throw Error("unable to locate global object") }(); "Promise" in l ? l.Promise.prototype["finally"] || (l.Promise.prototype["finally"] = e) : l.Promise = t });

            (function (self) {
                'use strict';

                if (self.fetch) {
                    return
                }

                var support = {
                    searchParams: 'URLSearchParams' in self,
                    iterable: 'Symbol' in self && 'iterator' in Symbol,
                    blob: 'FileReader' in self && 'Blob' in self && (function () {
                        try {
                            new Blob()
                            return true
                        } catch (e) {
                            return false
                        }
                    })(),
                    formData: 'FormData' in self,
                    arrayBuffer: 'ArrayBuffer' in self
                }

                if (support.arrayBuffer) {
                    var viewClasses = [
                        '[object Int8Array]',
                        '[object Uint8Array]',
                        '[object Uint8ClampedArray]',
                        '[object Int16Array]',
                        '[object Uint16Array]',
                        '[object Int32Array]',
                        '[object Uint32Array]',
                        '[object Float32Array]',
                        '[object Float64Array]'
                    ]

                    var isDataView = function (obj) {
                        return obj && DataView.prototype.isPrototypeOf(obj)
                    }

                    var isArrayBufferView = ArrayBuffer.isView || function (obj) {
                        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                    }
                }

                function normalizeName(name) {
                    if (typeof name !== 'string') {
                        name = String(name)
                    }
                    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                        throw new TypeError('Invalid character in header field name')
                    }
                    return name.toLowerCase()
                }

                function normalizeValue(value) {
                    if (typeof value !== 'string') {
                        value = String(value)
                    }
                    return value
                }

                // Build a destructive iterator for the value list
                function iteratorFor(items) {
                    var iterator = {
                        next: function () {
                            var value = items.shift()
                            return { done: value === undefined, value: value }
                        }
                    }

                    if (support.iterable) {
                        iterator[Symbol.iterator] = function () {
                            return iterator
                        }
                    }

                    return iterator
                }

                function Headers(headers) {
                    this.map = {}

                    if (headers instanceof Headers) {
                        headers.forEach(function (value, name) {
                            this.append(name, value)
                        }, this)
                    } else if (Array.isArray(headers)) {
                        headers.forEach(function (header) {
                            this.append(header[0], header[1])
                        }, this)
                    } else if (headers) {
                        Object.getOwnPropertyNames(headers).forEach(function (name) {
                            this.append(name, headers[name])
                        }, this)
                    }
                }

                Headers.prototype.append = function (name, value) {
                    name = normalizeName(name)
                    value = normalizeValue(value)
                    var oldValue = this.map[name]
                    this.map[name] = oldValue ? oldValue + ',' + value : value
                }

                Headers.prototype['delete'] = function (name) {
                    delete this.map[normalizeName(name)]
                }

                Headers.prototype.get = function (name) {
                    name = normalizeName(name)
                    return this.has(name) ? this.map[name] : null
                }

                Headers.prototype.has = function (name) {
                    return this.map.hasOwnProperty(normalizeName(name))
                }

                Headers.prototype.set = function (name, value) {
                    this.map[normalizeName(name)] = normalizeValue(value)
                }

                Headers.prototype.forEach = function (callback, thisArg) {
                    for (var name in this.map) {
                        if (this.map.hasOwnProperty(name)) {
                            callback.call(thisArg, this.map[name], name, this)
                        }
                    }
                }

                Headers.prototype.keys = function () {
                    var items = []
                    this.forEach(function (value, name) { items.push(name) })
                    return iteratorFor(items)
                }

                Headers.prototype.values = function () {
                    var items = []
                    this.forEach(function (value) { items.push(value) })
                    return iteratorFor(items)
                }

                Headers.prototype.entries = function () {
                    var items = []
                    this.forEach(function (value, name) { items.push([name, value]) })
                    return iteratorFor(items)
                }

                if (support.iterable) {
                    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
                }

                function consumed(body) {
                    if (body.bodyUsed) {
                        return Promise.reject(new TypeError('Already read'))
                    }
                    body.bodyUsed = true
                }

                function fileReaderReady(reader) {
                    return new Promise(function (resolve, reject) {
                        reader.onload = function () {
                            resolve(reader.result)
                        }
                        reader.onerror = function () {
                            reject(reader.error)
                        }
                    })
                }

                function readBlobAsArrayBuffer(blob) {
                    var reader = new FileReader()
                    var promise = fileReaderReady(reader)
                    reader.readAsArrayBuffer(blob)
                    return promise
                }

                function readBlobAsText(blob) {
                    var reader = new FileReader()
                    var promise = fileReaderReady(reader)
                    reader.readAsText(blob)
                    return promise
                }

                function readArrayBufferAsText(buf) {
                    var view = new Uint8Array(buf)
                    var chars = new Array(view.length)

                    for (var i = 0; i < view.length; i++) {
                        chars[i] = String.fromCharCode(view[i])
                    }
                    return chars.join('')
                }

                function bufferClone(buf) {
                    if (buf.slice) {
                        return buf.slice(0)
                    } else {
                        var view = new Uint8Array(buf.byteLength)
                        view.set(new Uint8Array(buf))
                        return view.buffer
                    }
                }

                function Body() {
                    this.bodyUsed = false

                    this._initBody = function (body) {
                        this._bodyInit = body
                        if (!body) {
                            this._bodyText = ''
                        } else if (typeof body === 'string') {
                            this._bodyText = body
                        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                            this._bodyBlob = body
                        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                            this._bodyFormData = body
                        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                            this._bodyText = body.toString()
                        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                            this._bodyArrayBuffer = bufferClone(body.buffer)
                            // IE 10-11 can't handle a DataView body.
                            this._bodyInit = new Blob([this._bodyArrayBuffer])
                        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                            this._bodyArrayBuffer = bufferClone(body)
                        } else {
                            throw new Error('unsupported BodyInit type')
                        }

                        if (!this.headers.get('content-type')) {
                            if (typeof body === 'string') {
                                this.headers.set('content-type', 'text/plain;charset=UTF-8')
                            } else if (this._bodyBlob && this._bodyBlob.type) {
                                this.headers.set('content-type', this._bodyBlob.type)
                            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
                            }
                        }
                    }

                    if (support.blob) {
                        this.blob = function () {
                            var rejected = consumed(this)
                            if (rejected) {
                                return rejected
                            }

                            if (this._bodyBlob) {
                                return Promise.resolve(this._bodyBlob)
                            } else if (this._bodyArrayBuffer) {
                                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                            } else if (this._bodyFormData) {
                                throw new Error('could not read FormData body as blob')
                            } else {
                                return Promise.resolve(new Blob([this._bodyText]))
                            }
                        }

                        this.arrayBuffer = function () {
                            if (this._bodyArrayBuffer) {
                                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                            } else {
                                return this.blob().then(readBlobAsArrayBuffer)
                            }
                        }
                    }

                    this.text = function () {
                        var rejected = consumed(this)
                        if (rejected) {
                            return rejected
                        }

                        if (this._bodyBlob) {
                            return readBlobAsText(this._bodyBlob)
                        } else if (this._bodyArrayBuffer) {
                            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
                        } else if (this._bodyFormData) {
                            throw new Error('could not read FormData body as text')
                        } else {
                            return Promise.resolve(this._bodyText)
                        }
                    }

                    if (support.formData) {
                        this.formData = function () {
                            return this.text().then(decode)
                        }
                    }

                    this.json = function () {
                        return this.text().then(JSON.parse)
                    }

                    return this
                }

                // HTTP methods whose capitalization should be normalized
                var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

                function normalizeMethod(method) {
                    var upcased = method.toUpperCase()
                    return (methods.indexOf(upcased) > -1) ? upcased : method
                }

                function Request(input, options) {
                    options = options || {}
                    var body = options.body

                    if (input instanceof Request) {
                        if (input.bodyUsed) {
                            throw new TypeError('Already read')
                        }
                        this.url = input.url
                        this.credentials = input.credentials
                        if (!options.headers) {
                            this.headers = new Headers(input.headers)
                        }
                        this.method = input.method
                        this.mode = input.mode
                        if (!body && input._bodyInit != null) {
                            body = input._bodyInit
                            input.bodyUsed = true
                        }
                    } else {
                        this.url = String(input)
                    }

                    this.credentials = options.credentials || this.credentials || 'omit'
                    if (options.headers || !this.headers) {
                        this.headers = new Headers(options.headers)
                    }
                    this.method = normalizeMethod(options.method || this.method || 'GET')
                    this.mode = options.mode || this.mode || null
                    this.referrer = null

                    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                        throw new TypeError('Body not allowed for GET or HEAD requests')
                    }
                    this._initBody(body)
                }

                Request.prototype.clone = function () {
                    return new Request(this, { body: this._bodyInit })
                }

                function decode(body) {
                    var form = new FormData()
                    body.trim().split('&').forEach(function (bytes) {
                        if (bytes) {
                            var split = bytes.split('=')
                            var name = split.shift().replace(/\+/g, ' ')
                            var value = split.join('=').replace(/\+/g, ' ')
                            form.append(decodeURIComponent(name), decodeURIComponent(value))
                        }
                    })
                    return form
                }

                function parseHeaders(rawHeaders) {
                    var headers = new Headers()
                    rawHeaders.split(/\r?\n/).forEach(function (line) {
                        var parts = line.split(':')
                        var key = parts.shift().trim()
                        if (key) {
                            var value = parts.join(':').trim()
                            headers.append(key, value)
                        }
                    })
                    return headers
                }

                Body.call(Request.prototype)

                function Response(bodyInit, options) {
                    if (!options) {
                        options = {}
                    }

                    this.type = 'default'
                    this.status = 'status' in options ? options.status : 200
                    this.ok = this.status >= 200 && this.status < 300
                    this.statusText = 'statusText' in options ? options.statusText : 'OK'
                    this.headers = new Headers(options.headers)
                    this.url = options.url || ''
                    this._initBody(bodyInit)
                }

                Body.call(Response.prototype)

                Response.prototype.clone = function () {
                    return new Response(this._bodyInit, {
                        status: this.status,
                        statusText: this.statusText,
                        headers: new Headers(this.headers),
                        url: this.url
                    })
                }

                Response.error = function () {
                    var response = new Response(null, { status: 0, statusText: '' })
                    response.type = 'error'
                    return response
                }

                var redirectStatuses = [301, 302, 303, 307, 308]

                Response.redirect = function (url, status) {
                    if (redirectStatuses.indexOf(status) === -1) {
                        throw new RangeError('Invalid status code')
                    }

                    return new Response(null, { status: status, headers: { location: url } })
                }

                self.Headers = Headers
                self.Request = Request
                self.Response = Response

                self.fetch = function (input, init) {
                    return new Promise(function (resolve, reject) {
                        var request = new Request(input, init)
                        var xhr = new XMLHttpRequest()

                        xhr.onload = function () {
                            var options = {
                                status: xhr.status,
                                statusText: xhr.statusText,
                                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                            }
                            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
                            var body = 'response' in xhr ? xhr.response : xhr.responseText
                            resolve(new Response(body, options))
                        }

                        xhr.onerror = function () {
                            reject(new TypeError('Network request failed'))
                        }

                        xhr.ontimeout = function () {
                            reject(new TypeError('Network request failed'))
                        }

                        xhr.open(request.method, request.url, true)

                        if (request.credentials === 'include') {
                            xhr.withCredentials = true
                        }

                        if ('responseType' in xhr && support.blob) {
                            xhr.responseType = 'blob'
                        }

                        request.headers.forEach(function (value, name) {
                            xhr.setRequestHeader(name, value)
                        })

                        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
                    })
                }
                self.fetch.polyfill = true
            })(typeof self !== 'undefined' ? self : this);
        </script>
    </asp:PlaceHolder>
    <script type="text/javascript">


        function CloseTask(taskid, isCloseFromButton) {
            var id;

            if (isCloseFromButton) {
                id = $('#TasksDivUL').find(".ui-tabs-selected").find("a")[0].href;
            }
            else
                id = '#T' + taskid;

            if ($('#TasksDiv') != null) $('#TasksDiv').tabs("remove", id);

            if ($('#T' + taskid) != null) $(id).remove();

            if ($('#TasksDiv').tabs("length") == 0) {
                $('#MainTabber').tabs("select", '#tabtasklist');
            }
        }

        function CheckAnyTaskOpen() {
            return ($('#TasksDiv').tabs("length") == 0);
        }

        function InsertOpen() {

            var destinationURL = "../Views/Insert/Insert.aspx";
            var newwindow = window.open(destinationURL, this.target, 'width=630,height=550,left=' + (screen.width - 600) / 2 + ',top=' + (screen.height - 580) / 2 + ',directories=no,status=no,menubar=no,toolbar=no,location=no,resizable=yes');
        }

        function InsertForm(formid, modal) {

            parent.InsertForm(formid, modal);
        }

        function AsociateForm(formid, docid, doctypeid, taskid, continueWithCurrentTasks, dontOpenTaskAfterInsert, fillCommonAttributes, haveSpecificAtt) {
            parent.AsociateForm(formid, docid, doctypeid, taskid, continueWithCurrentTasks, dontOpenTaskAfterInsert, fillCommonAttributes, haveSpecificAtt);
        }

        function ShowLoadingAnimation() {
            if (parent != this)
                parent.ShowLoadingAnimation();
        }
        function CloseThisTab() {
            CheckUserTimeOut()
            if (parent != this)
                parent.CloseThisTab();
        }
        function hideLoading() {
            if (parent != this)
                parent.hideLoading();
        }

        var t;

        function ResizeTBIframe(width, height) {
            try {

                if (parent !== this)
                    ResizeTBIframe($("#design").parent().width(), $("#design").parent().height());
            }
            catch (e) { }
        }

        var baseUrl = location.origin;

    </script>

    <asp:ContentPlaceHolder ID="header_js" runat="server">
    </asp:ContentPlaceHolder>
</head>

<body class="Body-Master-Blanck container-fluid" data-ng-app="app" style="padding-top: 99px">
    <div class="Div-principal-MasterBlank" id="divPrincipalMasterBlank">
        <form id="form2" runat="server" class="form" enctype="multipart/form-data" data-ng-controller="appController">

        
            <asp:HiddenField ID="hdReload" runat="server" Value="false"></asp:HiddenField>
            <asp:HiddenField ID="hdnUserId" runat="server" />
            <asp:HiddenField ID="hdnConnectionId" runat="server" />
            <asp:ScriptManager runat="server" ID="ScriptManager1" ScriptMode="Release" EnableScriptGlobalization="true" EnableScriptLocalization="true">
                <Services>
                    <asp:ServiceReference Path="~/Services/TaskService.asmx" />
                </Services>

            </asp:ScriptManager>

            <div>
                <asp:ContentPlaceHolder ID="ContentPlaceHolder" runat="server">
                </asp:ContentPlaceHolder>
            </div>
            <div>
                <div style="bottom: 0;">
                    <asp:ContentPlaceHolder ID="ContentPlaceFooter" runat="server">
                    </asp:ContentPlaceHolder>
                </div>
            </div>
        </form>
    </div>
    <asp:ContentPlaceHolder ID="footer_js" runat="server">
    </asp:ContentPlaceHolder>

</body>
</html>
